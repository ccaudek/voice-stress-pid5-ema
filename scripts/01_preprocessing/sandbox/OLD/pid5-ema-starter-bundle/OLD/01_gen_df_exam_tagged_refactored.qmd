---
title: "PID-5 EMA — Build analysis dataset (baseline + EMA + exam tags)"
subtitle: "Clean, tag, QA, and export"
author: "Corrado Caudek"
format:
  pdf:
    documentclass: article
    classoption: onecolumn
    papersize: a4
    geometry: [top=1in, left=1in, right=1in, bottom=1in]
    fontsize: 11pt
    linestretch: 1.05
    colorlinks: true
    number-sections: true
  html:
    toc: true
    number-sections: true
execute:
  echo: true
  warning: true
  message: true
editor: source
params:
  min_n_ema: 5       # minimum EMA responses per subject to keep
  export_path: "data/processed/ema_plus_baseline_exam_tagged_20250916.csv"
  # Exam dates (ISO: YYYY-MM-DD); edit as needed
  psico_pre:  ["2025-04-14", "2025-05-21"]
  psico_post: ["2025-04-15", "2025-05-22"]
  test_pre:   ["2025-04-14", "2025-05-25"]
  test_post:  ["2025-04-15", "2025-05-26"]
  interv_pre:  ["2025-05-12"]
  interv_post: ["2025-05-13"]
---

> Questa notebook costruisce **unico file analitico** per il progetto *PID‑5 EMA*, unendo:
> 1) **baseline** (PID‑5 domini senza item EMA, ESI‑BF, DASS‑21 baseline),  
> 2) **EMA** (misure dinamiche, incluse `happy/sad/satisfied/angry`, SCS di stato),  
> 3) **tag esame** (`exam_period`: baseline / pre_exam / post_exam),  
> 4) **filtri qualità** riproducibili.  
> Alla fine, salva `{{params.export_path}}` e stampa **log di inclusioni/esclusioni**.

## Setup

```{r}
suppressPackageStartupMessages({
  library(tidyverse)
  library(here)
  library(rio)
  library(stringr)
  library(lubridate)
  library(forcats)
  library(broom)
  library(glue)
  library(conflicted)
})

conflict_prefer("filter", "dplyr")
conflict_prefer("select", "dplyr")
conflict_prefer("sd", "stats")
conflict_prefer("var", "stats")

theme_set(theme_minimal(base_size = 12))
options(dplyr.summarise.inform = FALSE)
```

### Utility (coercioni sicure, somma NA‑robusta, clamp)

```{r}
# Coercizione numerica "safe"
to_num <- function(x) suppressWarnings(as.numeric(x))

# Clamp in [0, 100]
clamp_0_100 <- function(x) {
  x <- to_num(x)
  ifelse(is.na(x), NA_real_, pmin(pmax(x, 0), 100))
}

# Somma riga con NA‑robustezza ma torna NA se tutti gli addendi sono NA
row_sum_na_all_missing_na <- function(mat) {
  s <- rowSums(mat, na.rm = TRUE)
  all_na <- rowSums(!is.na(mat)) == 0
  s[all_na] <- NA_real_
  s
}
```

## 1) Import baseline: ESI‑BF e PID‑5 (domini, senza item EMA)

```{r}
# ESI-BF (già ricodificato e con user_id pulito dallo script `import_esi.R`)
esi_bf <- rio::import(here::here("data","processed","esi_bf.csv")) %>%
  distinct(user_id, .keep_all = TRUE) %>%
  select(user_id, esi_bf)
stopifnot(nrow(esi_bf) > 0, all(c("user_id","esi_bf") %in% names(esi_bf)))

# PID-5 (domini senza item EMA) da `import_pid5_subset.R`
pid5 <- rio::import(here::here("data","processed","pid5.csv")) %>%
  distinct(user_id, .keep_all = TRUE) %>%
  select(user_id, starts_with("domain_"))
stopifnot(nrow(pid5) > 0)

# Merge baseline
baseline <- left_join(esi_bf, pid5, by = "user_id")
```

### 1.1) Escludi careless responding (lista definita a priori)

```{r}
user_id_with_careless_responding <- c(
  "ma_se_2005_11_14_490","reve20041021036","di_ma_2005_10_20_756","pa_sc_2005_09_10_468",
  "il_re_2006_01_18_645","so_ma_2003_10_13_804","lo_ca_2005_05_07_05_437",
  "va_ma_2005_05_31_567","no_un_2005_06_29_880","an_bo_1988_08_24_166",
  "st_ma_2004_04_21_426","an_st_2005_10_16_052","vi_de_2002_12_30_067",
  "gi_ru_2005_03_08_033","al_mi_2005_03_05_844","la_ma_2006_01_31_787",
  "gi_lo_2004_06_27_237","ch_bi_2001_01_28_407","al_pe_2001_04_20_079",
  "le_de_2003_09_05_067","fe_gr_2002_02_19_434","ma_ba_2002_09_09_052",
  "ca_gi_2003_09_16_737","an_to_2003_08_06_114","al_se_2003_07_28_277",
  "ja_tr_2002_10_06_487","el_ci_2002_02_15_057","se_ti_2000_03_04_975",
  "co_ga_2003_10_29_614","al_ba_2003_18_07_905","bi_ro_2003_09_07_934",
  "an_va_2004_04_08_527","ev_cr_2003_01_27_573"
)

baseline <- baseline %>%
  mutate(flag_careless = user_id %in% user_id_with_careless_responding)

baseline_keep <- baseline %>% filter(!flag_careless)
baseline_drop <- baseline %>% filter(flag_careless) %>% select(user_id)
```

## 2) Import EMA e merge con baseline

```{r}
ema_raw <- readRDS(here::here("data","raw","ema","ema_data_scoring.RDS")) %>%
  rename(user_id = subj_code)

df0 <- left_join(baseline_keep %>% select(-flag_careless), ema_raw, by="user_id")
n_distinct(df0$user_id) -> n_users_after_careless
glue("Soggetti dopo esclusione careless: {n_users_after_careless}") %>% message()
```

### 2.1) Filtro per numerosità EMA (riportabile)

```{r}
counts <- df0 %>% count(user_id, name = "n_ema")
keep_ids <- counts %>% filter(n_ema >= 5 & n_ema <= 40) %>% pull(user_id)

df1 <- df0 %>% filter(user_id %in% keep_ids)

log_n <- tibble(
  step = c("after_careless","after_min_n_ema"),
  n_subjects = c(n_users_after_careless, n_distinct(df1$user_id))
)
log_n
```

## 3) Import metadati corso/sesso e tag esami

```{r}
exam_data <- rio::import(here::here("data","raw","all_combined_sex_NEW_1.xlsx")) %>%
  select(user_id = subj_code, course, sex)

df2 <- left_join(df1, exam_data, by="user_id")
```

### 3.1) Crea `exam_period` da calendario corsi

```{r}
# Parametri dalle YAML params
psico_pre   <- as.Date(params$psico_pre)
psico_post  <- as.Date(params$psico_post)
test_pre    <- as.Date(params$test_pre)
test_post   <- as.Date(params$test_post)
interv_pre  <- as.Date(params$interv_pre)
interv_post <- as.Date(params$interv_post)

df2 <- df2 %>%
  mutate(
    day = as.Date(day),
    exam_period = case_when(
      course == "Clinica" ~ "baseline",
      course == "Psicometria" & day %in% psico_pre  ~ "pre_exam",
      course == "Psicometria" & day %in% psico_post ~ "post_exam",
      course == "Testing"     & day %in% test_pre   ~ "pre_exam",
      course == "Testing"     & day %in% test_post  ~ "post_exam",
      course == "Interventi"  & day %in% interv_pre ~ "pre_exam",
      course == "Interventi"  & day %in% interv_post~ "post_exam",
      TRUE ~ "baseline"
    ),
    exam_period = factor(exam_period, levels = c("baseline","pre_exam","post_exam"))
  )

count(df2, course, exam_period)
```

## 4) Costruisci SCS di stato (cs_pos, ucs_neg) dalle colonne `scs*_pos/neg`

```{r}
pos_items <- names(df2)[str_detect(names(df2), "^scs\\d+_pos$")]
neg_items <- names(df2)[str_detect(names(df2), "^scs\\d+_neg$")]
stopifnot(length(pos_items) > 0, length(neg_items) > 0)

df2[pos_items] <- lapply(df2[pos_items], to_num)
df2[neg_items] <- lapply(df2[neg_items], to_num)

df2 <- df2 %>% mutate(
  cs_pos  = row_sum_na_all_missing_na(as.matrix(pick(all_of(pos_items)))),
  ucs_neg = row_sum_na_all_missing_na(as.matrix(pick(all_of(neg_items))))
)
```

## 5) Negative affect EMA da `happy/satisfied/sad/angry` (reverse su positivi)

```{r}
df2 <- df2 %>%
  mutate(
    happy     = clamp_0_100(happy),
    satisfied = clamp_0_100(satisfied),
    sad       = clamp_0_100(sad),
    angry     = clamp_0_100(angry),
    happy_rc     = if_else(is.na(happy),     NA_real_, 100 - happy),
    satisfied_rc = if_else(is.na(satisfied), NA_real_, 100 - satisfied)
  ) %>%
  mutate(
    negative_affect_ema_raw = row_sum_na_all_missing_na(as.matrix(pick(happy_rc, satisfied_rc, sad, angry)))
  ) %>%
  mutate(
    neg_affect_ema = as.numeric(scale(negative_affect_ema_raw))
  ) %>%
  select(-happy_rc, -satisfied_rc)
```

## 6) QA essenziale (riportabile nel manoscritto)

```{r}
qa_subjects <- df2 %>%
  group_by(user_id) %>%
  summarise(
    n_ema = n(),
    n_days = n_distinct(day),
    any_pre  = any(exam_period == "pre_exam", na.rm = TRUE),
    any_post = any(exam_period == "post_exam", na.rm = TRUE),
    any_base = any(exam_period == "baseline", na.rm = TRUE)
  ) %>%
  arrange(desc(n_ema))

print(qa_subjects, n = 10)

qa_missing <- df2 %>%
  summarise(
    pct_missing_neg_affect = mean(is.na(neg_affect_ema))*100,
    pct_missing_cs_pos     = mean(is.na(cs_pos))*100,
    pct_missing_ucs_neg    = mean(is.na(ucs_neg))*100
  )
qa_missing
```

### 6.1) Effetti del periodo d’esame stratificati per sesso (descrittivi)

```{r}
desc_by_sex <- df2 %>%
  filter(exam_period %in% c("pre_exam","post_exam")) %>%
  group_by(sex, exam_period) %>%
  summarise(
    n = n(),
    neg_aff_mean = mean(neg_affect_ema, na.rm = TRUE),
    cs_pos_mean  = mean(cs_pos, na.rm = TRUE),
    ucs_neg_mean = mean(ucs_neg, na.rm = TRUE)
  ) %>%
  arrange(sex, exam_period)

desc_by_sex
```



```{r}
# Import e scoring DASS-21 baseline
additional_quest_df <- rio::import(
  here::here("data", "raw", "quest", "2025_EMA_quest2.xlsx")
) |> rename(
  "user_id" = `Inserisci il tuo codice anonimo (esempio: ma_ro_1997_05_04_174)`
)

# Estrai items DASS-21 (colonne 3:20 e 22:24)
dass21_df <- additional_quest_df[, c(3:20, 22:24)]

# Funzioni di scoring DASS-21
map_dass21_response <- function(x) {
  if (is.numeric(x)) return(as.numeric(x))
  x0 <- tolower(str_squish(as.character(x)))
  dict <- c(
    "non mi è mai accaduto"                  = 0,
    "mi è capitato qualche volta"            = 1,
    "mi è capitato con una certa frequenza"  = 2,
    "mi è capitato quasi sempre"             = 3
  )
  out <- unname(dict[x0])
  bad <- is.na(out) & !is.na(x0)
  if (any(bad)) out[bad] <- suppressWarnings(as.numeric(x[bad]))
  as.numeric(out)
}

score_dass21_from_items <- function(df_items, na_rm = FALSE) {
  stopifnot(ncol(df_items) == 21L)
  items_num <- df_items %>% mutate(across(everything(), map_dass21_response))
  names(items_num) <- paste0("dass21_", seq_len(21))

  stress_idx     <- c(1, 6, 8, 11, 12, 14, 18)
  anxiety_idx    <- c(2, 4, 7, 9, 15, 19, 20)
  depression_idx <- c(3, 5, 10, 13, 16, 17, 21)

  sel <- function(idx) paste0("dass21_", idx)

  dass_stress     <- rowSums(items_num[, sel(stress_idx), drop = FALSE],     na.rm = na_rm)
  dass_anxiety    <- rowSums(items_num[, sel(anxiety_idx), drop = FALSE],    na.rm = na_rm)
  dass_depression <- rowSums(items_num[, sel(depression_idx), drop = FALSE], na.rm = na_rm)

  tibble(
    dass_stress_baseline     = dass_stress,
    dass_anxiety_baseline    = dass_anxiety,
    dass_depression_baseline = dass_depression
  )
}

# Calcola punteggi DASS-21
dass_scores <- score_dass21_from_items(
  df_items  = dass21_df,
  na_rm     = FALSE
)

# Crea dataframe con user_id e punteggi DASS-21
dass_baseline <- tibble(user_id = additional_quest_df$user_id) %>% 
  bind_cols(dass_scores) %>% 
  distinct(user_id, .keep_all = TRUE)

# Merge con baseline esistente
df3 <- left_join(df2, dass_baseline, by = "user_id")
```




## 7) Esporta dataset finale + log esclusioni

```{r}
# Log esclusioni
log_exclusions <- list(
  careless_ids = baseline_drop,
  min_n_ema_threshold = tibble(min_n_ema = params$min_n_ema,
                               dropped_ids = setdiff(unique(df0$user_id), unique(df1$user_id)))
)

# Dataset finale con rinomina PID‑5 baseline
dat_final <- df3 %>%
  rename(
    esi_bf_baseline = esi_bf,
    pid5_negative_affect_baseline = domain_negative_affect,
    pid5_detachment_baseline      = domain_detachment,
    pid5_antagonism_baseline      = domain_antagonism,
    pid5_disinhibition_baseline   = domain_disinhibition,
    pid5_psychoticism_baseline    = domain_psychoticism
  )

# Salva
rio::export(dat_final, here::here(params$export_path))

cat(glue("\nFile esportato: {here::here(params$export_path)}\n"))

# Mostra dimensioni e anteprima
dim(dat_final)
dat_final %>% arrange(user_id, day, hour) %>% slice_head(n = 8)
```

## 8) Nota su DASS‑21 baseline (opzionale)
Se desideri aggiungere i punteggi **DASS‑21 baseline** calcolati dalle 21 risposte testuali, aggiungi il blocco dedicato (vedi la tua sezione *Add DASS‑21*) e fai `left_join()` su `user_id` prima dell'export.



