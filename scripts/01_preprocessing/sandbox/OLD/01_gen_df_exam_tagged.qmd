---
title: "Genera file con tutte le colonne EMA, i punteggi statici e dinamici, e la codifica exam_period"
author: "Corrado Caudek"
format:
  pdf:
    documentclass: article
    classoption: onecolumn
    papersize: a4
    geometry:
      - top=1in
      - left=1in
      - right=1in
      - bottom=1in
    fontsize: 11pt
    linestretch: 1.0
    colorlinks: true
    lot: false
    lof: false
    highlight-style: github 
    # include-in-header: header.tex
    keep-tex: true
editor: source
---


```{r}
#| echo: false
#| output: false
#| 
# Load necessary libraries
library(tidyverse)
library(here)
library(rio)
library(brms)
library(stringr)
library(purrr)
library(cmdstanr)
options(mc.cores = parallel::detectCores())
library(loo)
library(ppcor)
library(tidyr)
library(broom)
library(tibble)
library(mice)
library(lubridate)
library(readxl)
library(forcats)

library(bayesplot)
theme_set(
  bayesplot::theme_default(
    base_size = 14,
    base_family = "sans"
  )
)
```

##  Dati PID-5 e ESI-BF (baseline)

Le misure "basali" corrispondenti ai 5 domini del PID-5 sono state calcolate **escludendo** i 15 item che vengono usati nelle notifiche EMA.

```{r}
# Importa i punteggi ESI-BF (fattore di rischio psicologico globale)
# e tiene solo un record per soggetto
esi_bf <- rio::import(
  here::here(
    "data",
    "processed",
    "esi_bf.csv"
  )
) |>
  dplyr::distinct(user_id, .keep_all = TRUE) |> # Keep only distinct user_id
  dplyr::select(user_id, esi_bf) # Select relevant columns

# Importa i punteggi del PID-5, escludendo gli item usati nell’EMA
pid5 <- rio::import(
  here::here(
    "data",
    "processed",
    "pid5.csv"
  )
) |>
  dplyr::distinct(user_id, .keep_all = TRUE) |>  # Keep only distinct user_id
  dplyr::select(user_id, starts_with("domain_")) # Select domain variables

# Merge dei dati basali in un unico dataframe
df <- left_join(esi_bf, pid5, by = "user_id")
```

## Pulizia iniziale dei dati

```{r}
# Elimina soggetti con risposte non affidabili (careless responding)
user_id_with_careless_responding <- c(
  "ma_se_2005_11_14_490",
  "reve20041021036",
  "di_ma_2005_10_20_756",
  "pa_sc_2005_09_10_468",
  "il_re_2006_01_18_645",
  "so_ma_2003_10_13_804",
  "lo_ca_2005_05_07_05_437",
  "va_ma_2005_05_31_567",
  "no_un_2005_06_29_880",
  "an_bo_1988_08_24_166",
  "st_ma_2004_04_21_426",
  "an_st_2005_10_16_052",
  "vi_de_2002_12_30_067",
  "gi_ru_2005_03_08_033",
  "al_mi_2005_03_05_844",
  "la_ma_2006_01_31_787",
  "gi_lo_2004_06_27_237",
  "ch_bi_2001_01_28_407",
  "al_pe_2001_04_20_079",
  "le_de_2003_09_05_067",
  "fe_gr_2002_02_19_434",
  "ma_ba_2002_09_09_052",
  "ca_gi_2003_09_16_737",
  "an_to_2003_08_06_114",
  "al_se_2003_07_28_277",
  "ja_tr_2002_10_06_487",
  "el_ci_2002_02_15_057",
  "se_ti_2000_03_04_975",
  "co_ga_2003_10_29_614",
  "al_ba_2003_18_07_905",
  "bi_ro_2003_09_07_934",
  "an_va_2004_04_08_527",
  "ev_cr_2003_01_27_573"
)

# Filter out users with careless responses
df1 <- df[!(df$user_id %in% user_id_with_careless_responding), ]
```

## Caricamento dati EMA

```{r}
# Legge i dati grezzi EMA e li unisce ai dati baseline
ema_raw <- readRDS(
  here::here(
    "data",
    "raw",
    "ema",
    "ema_data_scoring.RDS"
  )
) |>
  dplyr::rename(
    user_id = subj_code
  )

# Merge EMA data with filtered main data
df2 <- left_join(df1, ema_raw, by = "user_id")

# Verify number of unique users
length(unique(df2$user_id))
```

```{r}
# Conta quante risposte EMA ha fornito ciascun soggetto
user_counts <- df2 %>%
  group_by(user_id) %>%
  summarise(n_responses = n()) %>%
  ungroup()

valid_users <- user_counts %>%
  filter(n_responses >= 10) %>%
  pull(user_id)

# Tiene solo i soggetti con almeno 10 risposte EMA
df2 <- df2 %>%
  dplyr::filter(user_id %in% valid_users)
```

```{r}
length(unique(df2$user_id))
glimpse(df2)
```

## Creazione della data dell'esame

```{r}
# Importa i dati delle date d'esame per ogni soggetto
exam_data <- rio::import(
  here::here(
    "data", "raw", "all_combined_sex_NEW_1.xlsx"
  )
) %>%
  dplyr::select(
    user_id = subj_code, course, sex) # , name, surname, student_code 
```

```{r}
df3 <- left_join(df2, exam_data, by = "user_id")
```

```{r}
dim(df3)
```

```{r}
# Carico il file delle iscrizioni a e-l su Moodle:
# students_enrolled_to_el_moodle <- rio::import(
#   here::here(
#     "data", "raw", "courseid_2234_participants.xlsx"
#   )
# ) |> 
#   rename(
#     "name" = "Nome",
#     "surname" = "Cognome",
#     "student_code_2" = `Codice identificativo`,
#     "email" = `Indirizzo email`
#   ) |> 
#   dplyr::select(-Gruppi)
```

```{r}
summary(factor(df3$course))
```

```{r}
dat_final <- df3[!is.na(df3$course), ]
dim(dat_final)
```

```{r}
unique(dat_final$day) 
```

Date esami:

Psicometria e Testing: 14 aprile : pre-esame
Psicometria e Testing: 15 aprile : post-esame (giorno dell'esame)

Interventi 12/05 : pre-esame
Interventi 13/05 : post-esame

Psicometria 21/05: pre-esame
Psicometria 22/05: post-esame

Testing 25/05 : pre-esame
Testing 26/05 : post-esame

Clinica : non c'era l'esame: solo "baseline"


```{r}
# --- Date per corso (formato YYYY-MM-DD) ---
psico_pre   <- as.Date(c("2025-04-14", "2025-05-21"))
psico_post  <- as.Date(c("2025-04-15", "2025-05-22"))

test_pre    <- as.Date(c("2025-04-14", "2025-05-25"))
test_post   <- as.Date(c("2025-04-15", "2025-05-26"))

interv_pre  <- as.Date("2025-05-12")
interv_post <- as.Date("2025-05-13")

# --- Crea exam_period ---
dat_final <- dat_final %>%
  mutate(
    day = as.Date(day),
    exam_period = case_when(
      course == "Clinica" ~ "baseline",

      course == "Psicometria" & day %in% psico_pre  ~ "pre_exam",
      course == "Psicometria" & day %in% psico_post ~ "post_exam",

      course == "Testing" & day %in% test_pre  ~ "pre_exam",
      course == "Testing" & day %in% test_post ~ "post_exam",

      course == "Interventi" & day %in% interv_pre  ~ "pre_exam",
      course == "Interventi" & day %in% interv_post ~ "post_exam",

      TRUE ~ "baseline"   # tutte le altre date (o corsi non elencati)
    ),
    exam_period = factor(exam_period, levels = c("baseline", "pre_exam", "post_exam"))
  )

# (Opzionale) controllo rapido:
dplyr::count(dat_final, course, exam_period)
```

```{r}
dim(dat_final)
```

```{r}
# --- pattern già ok ---
pos_pat <- "^scs\\d+_pos$"
neg_pat <- "^scs\\d+_neg$"

pos_items <- names(dat_final)[str_detect(names(dat_final), pos_pat)]
neg_items <- names(dat_final)[str_detect(names(dat_final), neg_pat)]
stopifnot(length(pos_items) > 0, length(neg_items) > 0)
```

```{r}
# 1) Coercizione numerica sicura (se già numerici, non cambia nulla)
to_num <- function(x) suppressWarnings(as.numeric(x))
dat_final[pos_items] <- lapply(dat_final[pos_items], to_num)
dat_final[neg_items] <- lapply(dat_final[neg_items], to_num)

# 2) Matrici per somma riga
pos_mat <- as.matrix(dat_final[pos_items])
neg_mat <- as.matrix(dat_final[neg_items])

# 3) Somme riga con NA ignorati...
cs_pos  <- rowSums(pos_mat, na.rm = TRUE)
ucs_neg <- rowSums(neg_mat, na.rm = TRUE)

# ...ma se TUTTI gli item sono NA in quella riga, il composito deve essere NA
cs_pos[ rowSums(!is.na(pos_mat)) == 0 ]  <- NA_real_
ucs_neg[ rowSums(!is.na(neg_mat)) == 0 ] <- NA_real_

# 4) Scrivi nel data frame
dat_final$cs_pos  <- cs_pos
dat_final$ucs_neg <- ucs_neg
```

```{r}
# Assicura che exam_period sia un fattore (mantiene l'ordine attuale dei livelli)
dat_final <- dat_final %>%
  mutate(exam_period = as.factor(exam_period))

# ---- 1) Violin plot: SCS positiva (cs_pos) per exam_period -------------------
p_cs <- dat_final %>%
  dplyr::filter(!is.na(exam_period), !is.na(cs_pos)) %>%
  ggplot(aes(x = exam_period, y = cs_pos, fill = exam_period)) +
  geom_violin(trim = FALSE, alpha = 0.7) +
  stat_summary(fun = median, geom = "point", size = 1.8, color = "black") +
  labs(
    title = "SCS positiva per periodo d'esame",
    x = "Periodo d'esame",
    y = "SCS positiva (somma item)"
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")

# ---- 2) Violin plot: SCS negativa (ucs_neg) per exam_period ------------------
p_ucs <- dat_final %>%
  dplyr::filter(!is.na(exam_period), !is.na(ucs_neg)) %>%
  ggplot(aes(x = exam_period, y = ucs_neg, fill = exam_period)) +
  geom_violin(trim = FALSE, alpha = 0.7) +
  stat_summary(fun = median, geom = "point", size = 1.8, color = "black") +
  labs(
    title = "SCS negativa per periodo d'esame",
    x = "Periodo d'esame",
    y = "SCS negativa (somma item)"
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")

# ---- 3) (Opzionale) Grafico combinato con facet ------------------------------
long_scs <- dat_final %>%
  dplyr::select(exam_period, cs_pos, ucs_neg) %>%
  pivot_longer(cols = c(cs_pos, ucs_neg),
               names_to = "component",
               values_to = "score") %>%
  dplyr::filter(!is.na(exam_period), !is.na(score)) %>%
  mutate(component = recode(component,
                            cs_pos = "SCS positiva",
                            ucs_neg = "SCS negativa"))

p_both <- ggplot(long_scs, aes(x = exam_period, y = score, fill = exam_period)) +
  geom_violin(trim = FALSE, alpha = 0.7) +
  stat_summary(fun = median, geom = "point", size = 1.8, color = "black") +
  facet_wrap(~ component, ncol = 2, scales = "fixed") +
  labs(
    title = "Distribuzioni SCS positiva/negativa per periodo d'esame",
    x = "Periodo d'esame",
    y = "Somma item"
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "none")

# Stampa i grafici
print(p_cs)
print(p_ucs)
print(p_both)

# (Opzionale) Salvataggi
# ggsave("violin_cs_pos_by_exam_period.png", p_cs, width = 7, height = 5, dpi = 300)
# ggsave("violin_ucs_neg_by_exam_period.png", p_ucs, width = 7, height = 5, dpi = 300)
# ggsave("violin_scs_both_by_exam_period.png", p_both, width = 9, height = 5, dpi = 300)

```

```{r}
dim(dat_final)
```

```{r}
# 1) Tieni solo pre_exam e post_exam; imposta "pre_exam" come riferimento
dat_brm <- dat_final %>%
  dplyr::filter(exam_period %in% c("pre_exam", "post_exam")) %>%
  mutate(
    exam_period = fct_relevel(exam_period, "pre_exam"),
    user_id = factor(user_id)
  )
```

```{r}
# 2) Priors (debolmente informative)
pri <- c(
  prior(normal(0, 5), class = "Intercept"),
  prior(normal(0, 3), class = "b"),                 # effetto post_vs_pre
  prior(student_t(3, 0, 5), class = "sigma"),
  prior(student_t(3, 0, 5), class = "sd")           # varianza random intercept
)

# 3) Modello per cs_pos
m_cs <- brm(
  formula = cs_pos ~ 1 + exam_period + (1 | user_id),
  data    = dat_brm %>% dplyr::filter(!is.na(cs_pos)),
  family  = student(),
  prior   = pri,
  chains  = 4, cores = 4, iter = 4000, warmup = 1000,
  seed    = 1234,
  backend= "cmdstanr"
)
```

```{r}
pp_check(m_cs)
```

```{r}
summary(m_cs)
```

```{r}
conditional_effects(m_cs, "exam_period")
```

```{r}
# 4) Modello per ucs_neg
m_ucs <- brm(
  formula = ucs_neg ~ 1 + exam_period + (1 | user_id),
  data    = dat_brm %>% filter(!is.na(ucs_neg)),
  family  = student(),
  prior   = pri,
  chains  = 4, cores = 4, iter = 4000, warmup = 1000,
  seed    = 1234,
  backend = "cmdstanr"
)
```

```{r}
pp_check(m_ucs)
```

```{r}
summary(m_ucs)
```

```{r}
conditional_effects(m_ucs, "exam_period")
```

## Add DASS-21

Import il file finale che contiene altri questionari alla baseline

```{r}
additional_quest_df <- rio::import(
  here::here(
    "data", "raw", "quest", "2025_EMA_quest2.xlsx"
  )
) |> rename(
  "user_id" = `Inserisci il tuo codice anonimo (esempio: ma_ro_1997_05_04_174)`
)
```

DASS-21
da [3] "1) Ho provato molta tensione e ho avuto difficoltà a recuperare uno stato di calma"
fino a # [24] "22) Sentivo la vita priva di significato"
Item carelss: [21] "19) Scegli l'opzione \"Mi è capitato qualche volta\""

```{r}
dass21_df <- additional_quest_df[, c(3:20, 22:24)]
```

```{r}
# ------------------------------------------------------------
# 1) Funzioni: mappa le risposte IT -> 0..3 e calcola sottoscale
# ------------------------------------------------------------

# Mappa stringhe italiane DASS-21 in punteggi 0..3
map_dass21_response <- function(x) {
  if (is.numeric(x)) return(as.numeric(x))  # già numerico
  x0 <- tolower(str_squish(as.character(x)))
  dict <- c(
    "non mi è mai accaduto"                  = 0,
    "mi è capitato qualche volta"            = 1,
    "mi è capitato con una certa frequenza"  = 2,
    "mi è capitato quasi sempre"             = 3
  )
  out <- unname(dict[x0])
  bad <- is.na(out) & !is.na(x0)
  if (any(bad)) out[bad] <- suppressWarnings(as.numeric(x[bad]))
  as.numeric(out)
}

# Converte 21 colonne in dass21_1..21 (0..3) e restituisce anche le 3 sottoscale
score_dass21_from_items <- function(df_items, na_rm = FALSE, multiply2 = FALSE) {
  stopifnot(ncol(df_items) == 21L)
  items_num <- df_items %>% mutate(across(everything(), map_dass21_response))
  names(items_num) <- paste0("dass21_", seq_len(21))

  stress_idx     <- c(1, 6, 8, 11, 12, 14, 18)
  anxiety_idx    <- c(2, 4, 7, 9, 15, 19, 20)
  depression_idx <- c(3, 5, 10, 13, 16, 17, 21)

  sel <- function(idx) paste0("dass21_", idx)

  dass_stress     <- rowSums(items_num[, sel(stress_idx), drop = FALSE],     na.rm = na_rm)
  dass_anxiety    <- rowSums(items_num[, sel(anxiety_idx), drop = FALSE],    na.rm = na_rm)
  dass_depression <- rowSums(items_num[, sel(depression_idx), drop = FALSE], na.rm = na_rm)

  if (multiply2) {
    dass_stress     <- dass_stress * 2
    dass_anxiety    <- dass_anxiety * 2
    dass_depression <- dass_depression * 2
  }

  tibble(
    dass_stress_baseline     = dass_stress,   # ho cambiato qui!!!
    dass_anxiety_baseline    = dass_anxiety,
    dass_depression_baseline = dass_depression
  )
}
```

```{r}
# ------------------------------------------------------------
# 2) Calcola i punteggi dai tuoi dati originali (21 colonne testuali)
# ------------------------------------------------------------

# ATTENZIONE: si assume che le 21 colonne di `dass21_df` siano nell'ordine 1..21
dass_scores <- score_dass21_from_items(
  df_items  = dass21_df,
  na_rm     = FALSE,   # TRUE se vuoi ignorare eventuali NA nella somma
  multiply2 = FALSE    # TRUE se vuoi i punteggi *2 (prassi in alcuni report)
)
```


```{r}
# ------------------------------------------------------------
# 3) Aggancia `user_id` ai punteggi DASS (scegli A o B)
# ------------------------------------------------------------

## A) Hai un vettore di ID allineato alle righe di dass21_df
# stopifnot(exists("dass_user_id"), length(dass_user_id) == nrow(dass21_df))
# dass_by_id <- tibble(user_id = as.character(dass_user_id)) %>%
#   bind_cols(dass_scores)

## B) Hai un data frame con la colonna user_id allineata alle righe (es. dass21_meta)
stopifnot(exists("additional_quest_df"), nrow(additional_quest_df) == nrow(dass21_df), "user_id" %in% names(additional_quest_df))
dass_by_id <- additional_quest_df %>%
  transmute(user_id = as.character(user_id)) %>%
  bind_cols(dass_scores)

# SCEGLI UNO tra A o B; poi rimuovi i commenti (togli #) alla soluzione scelta.
# Per proseguire, qui metto un placeholder che va sostituito con A o B:
# ---- INIZIO: rimpiazza questa riga con A o B ----
# stop("Scegli e attiva il blocco A) o B) per costruire 'dass_by_id'.")
# ---- FINE: rimpiazza questa riga con A o B ----

# ------------------------------------------------------------
# 4) Join a dat_final (replica i punteggi su tutte le righe dello stesso soggetto)
# ------------------------------------------------------------

dass_by_id_unique <- dass_by_id %>%
  arrange(user_id) %>%
  dplyr::distinct(user_id, .keep_all = TRUE)

dat2_final <- left_join(dat_final, dass_by_id_unique, by="user_id")
dim(dat2_final)
```

```{r}
dat3_final <- dat2_final |> 
  rename(
    esi_bf_baseline = esi_bf,
    pid5_negative_affect_baseline = domain_negative_affect,
    pid5_detachment_baseline = domain_detachment,
    pid5_antagonism_baseline = domain_antagonism,
    pid5_disinhibition_baseline = domain_disinhibition,
    pid5_psychoticism_baseline = domain_psychoticism
  )
```

cs_pos, ucs_neg: EMA delle due componenti della self-compassion

Componenti EMA del COPE:
cope_avoid      
cope_prob_or      
cope_social_support         
cope_positive_att           
cope_trascendent_or      

Componenti EMA della DASS-21:
dass_stress, dass_depression, dass_anxiety (dass_sum)

Componenti EMA del Tri-PM:
tripm_boldness
tripm_meanness

Intimate Partner Violence EMA:
ipv_sum 

Componenti del PID-5 EMA:
pid5_negative_affectivity, pid5_detachment, pid5_antagonism, pid5_disinhibition,
pid5_psychoticism

Contesto EMA (4 item separati):
context_quality, context_control, context_support, context_threat

Emotional state EMA:
happy, sad, satisfied, angry

```{r}
# Funzione di sicurezza: coercizione numerica + clamp 0..100
clamp_0_100 <- function(x) {
  x <- suppressWarnings(as.numeric(x))
  ifelse(is.na(x), NA_real_, pmin(pmax(x, 0), 100))
}

dat3_final <- dat3_final %>%
  mutate(
    # 1) Normalizza range 0..100 (se già ok, non cambia nulla)
    happy     = clamp_0_100(happy),
    satisfied = clamp_0_100(satisfied),
    sad       = clamp_0_100(sad),
    angry     = clamp_0_100(angry),

    # 2) Reverse scoring per happy e satisfied
    happy_rc     = if_else(is.na(happy),     NA_real_, 100 - happy),
    satisfied_rc = if_else(is.na(satisfied), NA_real_, 100 - satisfied),

    # 3) Composito: somma (NA-robusto ma NA se tutti mancanti)
    n_aff_items_answered = rowSums(!is.na(pick(happy_rc, satisfied_rc, sad, angry))),
    negative_affect_ema = if_else(
      n_aff_items_answered == 0,
      NA_real_,
      rowSums(pick(happy_rc, satisfied_rc, sad, angry), na.rm = TRUE)
    )
  ) %>%
  # 4) (Opzionale) rimuovi le colonne ausiliarie
  dplyr::select(-happy_rc, -satisfied_rc)

dat3_final$neg_affect_ema <- as.numeric(scale(dat3_final$negative_affect_ema))
dat3_final$negative_affect_ema <- NULL
```

## Save data

Questionari: PID-5 alla baseline, ESI-BF alla baseline, e DASS-21 alla baseline.

```{r}
rio::export(dat3_final, file = here::here("data", "processed", "ema_plus_baseline_exam_tagged.csv"))
```




